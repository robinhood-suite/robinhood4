#!/bin/bash

# This file is part of RobinHood 4
# Copyright (C) 2025 Commissariat a l'energie atomique et aux energies
#                    alternatives
#
# SPDX-License-Identifer: LGPL-3.0-or-later

for program in rbh-sync rbh-find rbh-fsevents rbh-info; do
    if ! command -v $program &> /dev/null; then
        echo "This command requires $program to be installed"
        exit 1
    fi
done

function update_directory_expiration_date
{
    local URI="$1"
    local directory_ID="$2"
    local expiration_date="$3"

    rbh-fsevents - "$URI" <<EOF
--- !inode_xattr
"id": !!binary $directory_ID
"xattrs":
  "trusted.expiration_date": !int64 $expiration_date
...
EOF
}

function update_expiration_date
{
    local URI="$1"
    local directory="$2"
    local directory_ID="$3"
    local expires="$4"
    local verbose="$5"

    local new_expiration_date=$((max_time + expires + 1))

    if [ ! -z "$verbose" ]; then
        echo "Expiration of the directory should occur '$expires' seconds after it's last usage"
        echo "Changing the expiration date of '$directory' to '$(date -d "@$new_expiration_date")'"
    fi

    update_directory_expiration_date "$URI" "$directory_ID" \
                                     "$new_expiration_date"
    setfattr -n trusted.expiration_date -v "$new_expiration_date" \
                                           "$mount_point/$directory"
}

function check_expiration_date
{
    local URI="$1"
    local directory="$2"
    local directory_ID="$3"
    local expires="$4"
    local expiration_date="$5"
    local mount_point="$6"

    local max_time=$(rbh-find "$URI#$directory" \
                        -type f -printf "%A\n%T\n" | sort -rn | head -n 1)

    if [ -z "$max_time" ]; then
        max_time="0"
    fi

    local actual_exp_date="$(( max_time + expires ))"

    if (( actual_exp_date <= current )); then
        # All entries here are considered truly expired and could be deleted
        echo "Directory '$directory' expiration date is set to '$expiration_date'"

        if (( max_time == 0 )); then
            echo "Directory '$directory' has expired and it is empty, no other check needed"

            if [ ! -z "$delete_found" ] && [ ! -z "$directory" ]; then
                find "$mount_point/$directory" -depth -exec "rmdir" {} ";"
            fi
        else
            echo "The last accessed file in it was accessed on '$(date -d "@$max_time")'"
            echo "Expiration of the directory should occur '$expires' seconds after it's last usage"
            if [ ! -z "$delete_found" ] && [ ! -z "$directory" ]; then
                echo "Directory '$directory' has expired and will be deleted"
                rm -rf "$mount_point/$directory"
            else
                echo "Directory '$directory' has expired"
            fi
        fi

        return 0
    fi

    # Here we only have entries which are expired after the delay, but not truly

    if (( actual_exp_date >= delay )); then
        # If the directory truly expires after the delay

        if (( $(date +%s -d "$expiration_date") <= current )); then
            # The directory has expired, but an entry in it has pushed that
            # expiration date back, so update it and notify the user
            update_expiration_date "$URI" "$directory" "$directory_ID" \
                                   "$expires" --verbose
        else
            # The directory will expire during the delay window, but since an
            # entry in it pushes back the expiration date, update it, but don't
            # bother notifying the user
            update_expiration_date "$URI" "$directory" "$directory_ID" \
                                   "$expires"
        fi
    else
        # Otherwise the directory will truly expire during the delay, so provide
        # a countdown to its expiration
        local exp_days="$(( (actual_exp_date - current) / 86400))"

        echo "Directory '$directory' expiration date is set to '$expiration_date'"
        echo "So '$directory' expires in $exp_days days"
    fi
}

function handle_non_relative_expiration()
{
    local directory="$1"
    local expiration_date="$2"
    local expires="$3"
    local mount_point="$4"

    echo "Directory '$directory' expired on '$expiration_date'"

    if [ "$expires" == "None" ]; then
        echo "Expiration attribute is unknown, so we cannot determine if the" \
             "directory is really expired or not. Skipping '$directory'"
        return 0
    fi

    if [ ! -z "$delete_found" ] && [ ! -z "$directory" ]; then
        rm -rf "$mount_point/$directory"
    fi
}

function run_retention_updater
{
    local URI="$1"
    local mount_point
    local tmp_file="$(mktemp tmp.XXXXXX)"
    local config_option

    if [ ! -z "$conf_file" ]; then
        config_option="--config $conf_file"
    else
        config_option=""
    fi

    mount_point="$(rbh-info $URI -m)"

    rbh-find $config_option $URI -type d \
             -expired-at "$delay" -printf "%p|%e|%E|%I\n" |
        while IFS='|' read -r dir expires expiration_date ID; do

        if [ "${expires:0:1}" != "+" ]; then
            handle_non_relative_expiration "$dir" "$expiration_date" \
                                           "$expires" "$mount_point"

            echo "true" > $tmp_file

            continue
        fi

        check_expiration_date "$URI" "$dir" "$ID" "$expires" \
                              "$expiration_date" "$mount_point"
        echo "true" > $tmp_file
    done

    local found_something="$(cat $tmp_file)"
    if [ -z "$found_something" ]; then
        echo "No directory has expired"
    fi

    rm $tmp_file
}

function print_doc
{
    echo "Usage: rbh-update-retention URI [--delete] [--config PATH] [--help] [--delay DELAY]"
    echo ""
    echo "Update the retention of attributes of any directory that is expired,"
    echo "based on their content's last accessed time."
    echo "If a directory is expired, it is printed to the output."
    echo ""
    echo "'--config PATH'   path to a configuration file, used to determine the"
    echo "                  expiration attribute to check for"
    echo "'--delay'         a delay window during which entries that will"
    echo "                  expire should be notified. Should be given as a"
    echo "                  number of days. If not given, no delay shall be"
    echo "                  used"
    echo "'--delete'        delete the expired directories instead of just"
    echo "                  printing"
    echo "'--help'          print this message"
    echo ""
}

if [ $# -lt 1 ]; then
    echo "Please specify a URI to update"
    echo ""
    print_doc
    exit 1
fi

current="$(date +%s)"
delay="$current"

while :
do
    if [ -z "$1" ]; then
        break
    fi

    case "$1" in
        --delete)
            if [ "$delete_found" == "true" ]; then
                echo "Delete option already given"
                exit 1
            fi
            delete_found=true
            ;;
        --help)
            print_doc
            exit 0
            ;;
        --config)
            if [ "$config_found" == "true" ]; then
                echo "Config option already given"
                exit 1
            fi

            config_found=true
            conf_file="$2"
            shift
            ;;
        --delay)
            if [ "$delay_found" == "true" ]; then
                echo "Delay option already given"
                exit 1
            fi

            delay="$(date +%s -d "+ $2 days")"
            shift
            ;;
        *)
            if [ "$args_found" == "true" ]; then
                echo "URI already given"
                exit 1
            fi

            URI="$1"
            args_found=true
            ;;
    esac

    shift
done

run_retention_updater "$URI"
